# GitLab CI/CD с Kubernetes executor и Kaniko
# Kaniko позволяет собирать Docker образы без Docker daemon

stages:
  - lint
  - test
  - build
  - deploy

variables:
  # Kaniko переменные
  KANIKO_IMAGE: gcr.io/kaniko-project/executor:latest
  KANIKO_CACHE_REPO: $CI_REGISTRY_IMAGE/cache
  DOCKERFILE_PATH: ./Dockerfile
  CONTEXT_PATH: .

  # Образ приложения
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA

# ========================================
# LINT STAGE
# ========================================

lint:code:
  stage: lint
  image: node:18-alpine
  tags:
    - kubernetes  # Указываем тег для Kubernetes runner
  script:
    - npm ci
    - npm run lint
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
  only:
    - merge_requests
    - main

lint:dockerfile:
  stage: lint
  image: hadolint/hadolint:latest-alpine
  tags:
    - kubernetes
  script:
    - hadolint $DOCKERFILE_PATH
  allow_failure: true

# ========================================
# TEST STAGE
# ========================================

test:unit:
  stage: test
  image: node:18-alpine
  tags:
    - kubernetes
  services:
    - name: postgres:15-alpine
      alias: postgres
    - name: redis:7-alpine
      alias: redis
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: postgresql://test_user:test_password@postgres:5432/test_db
    REDIS_URL: redis://redis:6379

    # Kubernetes executor специфичные настройки
    KUBERNETES_MEMORY_REQUEST: "512Mi"
    KUBERNETES_MEMORY_LIMIT: "1Gi"
    KUBERNETES_CPU_REQUEST: "250m"
    KUBERNETES_CPU_LIMIT: "500m"
  before_script:
    - npm ci
  script:
    - npm run test -- --coverage --ci
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/

# ========================================
# BUILD STAGE с Kaniko
# ========================================

# Базовая сборка с Kaniko
build:kaniko-basic:
  stage: build
  image:
    name: $KANIKO_IMAGE
    entrypoint: [""]
  tags:
    - kubernetes
  script:
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor
        --context $CONTEXT_PATH
        --dockerfile $DOCKERFILE_PATH
        --destination $IMAGE_NAME:$IMAGE_TAG
        --destination $IMAGE_NAME:latest
  only:
    - main
    - develop

# Kaniko с кешированием слоев
build:kaniko-cached:
  stage: build
  image:
    name: $KANIKO_IMAGE
    entrypoint: [""]
  tags:
    - kubernetes
  variables:
    KUBERNETES_MEMORY_REQUEST: "1Gi"
    KUBERNETES_MEMORY_LIMIT: "2Gi"
    KUBERNETES_CPU_REQUEST: "500m"
    KUBERNETES_CPU_LIMIT: "1000m"
  before_script:
    # Создание конфигурации Docker registry
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  script:
    - /kaniko/executor
        --context $CONTEXT_PATH
        --dockerfile $DOCKERFILE_PATH
        --destination $IMAGE_NAME:$IMAGE_TAG
        --destination $IMAGE_NAME:latest
        --cache=true
        --cache-repo=$KANIKO_CACHE_REPO
        --cache-ttl=24h
        --compressed-caching=false
        --snapshot-mode=redo
        --use-new-run
  only:
    - main
    - develop
    - tags

# Kaniko с build args и labels
build:kaniko-advanced:
  stage: build
  image:
    name: $KANIKO_IMAGE
    entrypoint: [""]
  tags:
    - kubernetes
  variables:
    KUBERNETES_MEMORY_REQUEST: "1Gi"
    KUBERNETES_MEMORY_LIMIT: "2Gi"
  before_script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  script:
    - /kaniko/executor
        --context $CONTEXT_PATH
        --dockerfile $DOCKERFILE_PATH
        --destination $IMAGE_NAME:$IMAGE_TAG
        --destination $IMAGE_NAME:$CI_COMMIT_REF_SLUG
        --cache=true
        --cache-repo=$KANIKO_CACHE_REPO
        --build-arg VERSION=$CI_COMMIT_TAG
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        --build-arg VCS_REF=$CI_COMMIT_SHA
        --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
        --label "org.opencontainers.image.authors=DevOps Team"
        --label "org.opencontainers.image.url=$CI_PROJECT_URL"
        --label "org.opencontainers.image.source=$CI_REPOSITORY_URL"
        --label "org.opencontainers.image.version=$CI_COMMIT_TAG"
        --label "org.opencontainers.image.revision=$CI_COMMIT_SHA"
        --label "org.opencontainers.image.title=$CI_PROJECT_NAME"
        --verbosity=info
  only:
    - main
    - tags

# Multi-stage build с Kaniko
build:kaniko-multistage:
  stage: build
  image:
    name: $KANIKO_IMAGE
    entrypoint: [""]
  tags:
    - kubernetes
  before_script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  script:
    # Сборка только определенного stage
    - /kaniko/executor
        --context $CONTEXT_PATH
        --dockerfile $DOCKERFILE_PATH
        --target production
        --destination $IMAGE_NAME:$IMAGE_TAG-prod
        --cache=true
        --cache-repo=$KANIKO_CACHE_REPO
  only:
    - tags

# Сканирование образа после сборки
scan:trivy:
  stage: build
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  tags:
    - kubernetes
  dependencies:
    - build:kaniko-cached
  script:
    - trivy image
        --severity HIGH,CRITICAL
        --exit-code 0
        --format json
        --output trivy-report.json
        $IMAGE_NAME:$IMAGE_TAG
    - trivy image
        --severity HIGH,CRITICAL
        --exit-code 1
        $IMAGE_NAME:$IMAGE_TAG
  artifacts:
    reports:
      container_scanning: trivy-report.json
  allow_failure: true

# ========================================
# DEPLOY STAGE
# ========================================

deploy:staging:
  stage: deploy
  image: bitnami/kubectl:latest
  tags:
    - kubernetes
  environment:
    name: staging
    url: https://staging.example.com
    kubernetes:
      namespace: staging
  variables:
    KUBERNETES_MEMORY_REQUEST: "256Mi"
    KUBERNETES_MEMORY_LIMIT: "512Mi"
  before_script:
    - kubectl config use-context $KUBE_CONTEXT
  script:
    - kubectl set image deployment/myapp
        myapp=$IMAGE_NAME:$IMAGE_TAG
        -n staging
    - kubectl rollout status deployment/myapp -n staging --timeout=5m
    - kubectl get pods -n staging
  only:
    - develop
  when: manual

deploy:production:
  stage: deploy
  image: bitnami/kubectl:latest
  tags:
    - kubernetes
  environment:
    name: production
    url: https://example.com
    kubernetes:
      namespace: production
  before_script:
    - kubectl config use-context $KUBE_CONTEXT
  script:
    - kubectl set image deployment/myapp
        myapp=$IMAGE_NAME:$IMAGE_TAG
        -n production
    - kubectl rollout status deployment/myapp -n production --timeout=10m
    - kubectl get pods -n production
  only:
    - main
  when: manual

# ========================================
# Пример использования Helm
# ========================================

deploy:helm:
  stage: deploy
  image: alpine/helm:latest
  tags:
    - kubernetes
  environment:
    name: production
    url: https://example.com
  before_script:
    - kubectl config use-context $KUBE_CONTEXT
  script:
    - helm upgrade --install myapp ./helm-chart
        --namespace production
        --create-namespace
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --wait
        --timeout 10m
  only:
    - main
  when: manual

# ========================================
# Cleanup старых образов
# ========================================

cleanup:registry:
  stage: deploy
  image: alpine:latest
  tags:
    - kubernetes
  before_script:
    - apk add --no-cache curl jq
  script:
    # Удаление тегов старше 30 дней (кроме latest и последних 10)
    - |
      TAGS=$(curl --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/registry/repositories" | \
        jq -r '.[].id')

      for REPO_ID in $TAGS; do
        curl --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/registry/repositories/$REPO_ID/tags" | \
          jq -r '.[] | select(.created_at < (now - 2592000 | strftime("%Y-%m-%dT%H:%M:%S.%fZ"))) | .name' | \
          head -n -10 | \
          while read TAG; do
            echo "Deleting tag: $TAG"
            curl --request DELETE --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
              "$CI_API_V4_URL/projects/$CI_PROJECT_ID/registry/repositories/$REPO_ID/tags/$TAG"
          done
      done
  only:
    - schedules
  when: manual
