# GitLab CI/CD - Single Repository с деплоем через kubeconfig
# Все в одном репозитории: код + Helm charts + деплой

stages:
  - lint
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  HELM_VERSION: "3.12.0"

# ========================================
# LINT STAGE
# ========================================

lint:code:
  stage: lint
  image: node:18-alpine
  before_script:
    - npm ci
  script:
    - npm run lint
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
  only:
    - merge_requests
    - main
    - develop

lint:helm:
  stage: lint
  image: alpine/helm:${HELM_VERSION}
  script:
    - helm lint ./helm-chart
  only:
    - merge_requests
    - main

# ========================================
# TEST STAGE
# ========================================

test:unit:
  stage: test
  image: node:18-alpine
  services:
    - postgres:15-alpine
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
  before_script:
    - npm ci
  script:
    - npm run test -- --coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/

# ========================================
# BUILD STAGE
# ========================================

build:docker:
  stage: build
  image: docker:24-alpine
  services:
    - docker:24-dind
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - docker build -t $IMAGE_NAME:$IMAGE_TAG .
    - docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:$CI_COMMIT_REF_SLUG
    - docker push $IMAGE_NAME:$IMAGE_TAG
    - docker push $IMAGE_NAME:$CI_COMMIT_REF_SLUG
  only:
    - main
    - develop

# ========================================
# DEPLOY STAGE - Метод 1: Kubeconfig из переменной
# ========================================

deploy:staging:kubeconfig-var:
  stage: deploy
  image: alpine/helm:${HELM_VERSION}
  before_script:
    # Создаем kubeconfig из переменной окружения
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_STAGING" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config

    # Проверяем подключение
    - kubectl cluster-info
    - kubectl get nodes
  script:
    # Деплой с Helm
    - helm upgrade --install myapp ./helm-chart
        --namespace staging
        --create-namespace
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --set environment=staging
        --values ./helm-chart/values-staging.yaml
        --wait
        --timeout 5m

    # Проверка деплоя
    - kubectl get pods -n staging
    - kubectl rollout status deployment/myapp -n staging
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop
  when: manual

# ========================================
# DEPLOY STAGE - Метод 2: Kubeconfig по частям
# ========================================

deploy:staging:kubeconfig-manual:
  stage: deploy
  image: bitnami/kubectl:latest
  before_script:
    # Создаем kubeconfig вручную из отдельных переменных
    - mkdir -p ~/.kube
    - |
      cat > ~/.kube/config <<EOF
      apiVersion: v1
      kind: Config
      clusters:
      - cluster:
          server: ${KUBE_URL}
          certificate-authority-data: ${KUBE_CA_CERT}
        name: kubernetes
      contexts:
      - context:
          cluster: kubernetes
          user: gitlab
        name: gitlab
      current-context: gitlab
      users:
      - name: gitlab
        user:
          token: ${KUBE_TOKEN}
      EOF
    - chmod 600 ~/.kube/config
    - kubectl cluster-info
  script:
    # Обновляем deployment
    - kubectl set image deployment/myapp
        myapp=$IMAGE_NAME:$IMAGE_TAG
        -n staging

    # Ждем завершения rollout
    - kubectl rollout status deployment/myapp -n staging --timeout=5m

    # Проверяем статус
    - kubectl get pods -n staging -l app=myapp
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop
  when: manual

# ========================================
# DEPLOY STAGE - Метод 3: kubectl config commands
# ========================================

deploy:staging:kubectl-config:
  stage: deploy
  image: alpine/helm:${HELM_VERSION}
  before_script:
    # Настройка kubectl через команды
    - kubectl config set-cluster kubernetes --server="${KUBE_URL}"
    - kubectl config set clusters.kubernetes.certificate-authority-data "${KUBE_CA_CERT}"
    - kubectl config set-credentials gitlab --token="${KUBE_TOKEN}"
    - kubectl config set-context gitlab --cluster=kubernetes --user=gitlab
    - kubectl config use-context gitlab

    # Проверка
    - kubectl version --short
    - kubectl cluster-info
  script:
    - helm upgrade --install myapp ./helm-chart
        --namespace staging
        --create-namespace
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --values ./helm-chart/values-staging.yaml
        --wait
        --timeout 5m
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop
  when: manual

# ========================================
# DEPLOY STAGE - Метод 4: Insecure (для self-signed certs)
# ========================================

deploy:staging:insecure:
  stage: deploy
  image: alpine/helm:${HELM_VERSION}
  before_script:
    # Для кластеров с self-signed сертификатами
    - kubectl config set-cluster kubernetes
        --server="${KUBE_URL}"
        --insecure-skip-tls-verify=true
    - kubectl config set-credentials gitlab --token="${KUBE_TOKEN}"
    - kubectl config set-context gitlab --cluster=kubernetes --user=gitlab
    - kubectl config use-context gitlab
  script:
    - helm upgrade --install myapp ./helm-chart
        --namespace staging
        --create-namespace
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --values ./helm-chart/values-staging.yaml
        --wait
  environment:
    name: staging
  only:
    - develop
  when: manual

# ========================================
# DEPLOY STAGE - Production с проверками
# ========================================

deploy:production:
  stage: deploy
  image: alpine/helm:${HELM_VERSION}
  before_script:
    # Настройка kubectl
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_PRODUCTION" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config
    - kubectl cluster-info
  script:
    # Backup текущей конфигурации
    - helm get values myapp -n production -o yaml > backup-values.yaml 2>/dev/null || true

    # Dry-run для проверки
    - helm upgrade --install myapp ./helm-chart
        --namespace production
        --create-namespace
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --values ./helm-chart/values-production.yaml
        --dry-run
        --debug

    # Реальный деплой
    - helm upgrade --install myapp ./helm-chart
        --namespace production
        --create-namespace
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --values ./helm-chart/values-production.yaml
        --wait
        --timeout 10m
        --atomic  # Автоматический откат при ошибке

    # Проверка статуса
    - helm status myapp -n production
    - kubectl get pods -n production -l app=myapp
    - kubectl get svc -n production -l app=myapp
  artifacts:
    paths:
      - backup-values.yaml
    expire_in: 30 days
    when: always
  environment:
    name: production
    url: https://example.com
  only:
    - main
    - tags
  when: manual

# ========================================
# DEPLOY STAGE - Применение манифестов напрямую
# ========================================

deploy:staging:kubectl-apply:
  stage: deploy
  image: bitnami/kubectl:latest
  before_script:
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_STAGING" | base64 -d > ~/.kube/config
  script:
    # Генерация манифестов из Helm
    - helm template myapp ./helm-chart
        --set image.repository=$IMAGE_NAME
        --set image.tag=$IMAGE_TAG
        --values ./helm-chart/values-staging.yaml
        --output-dir ./manifests

    # Применение манифестов
    - kubectl apply -f ./manifests/myapp/templates/ -n staging

    # Ждем готовности
    - kubectl wait --for=condition=available
        deployment/myapp
        -n staging
        --timeout=5m
  artifacts:
    paths:
      - manifests/
  environment:
    name: staging
  only:
    - develop
  when: manual

# ========================================
# Rollback
# ========================================

rollback:production:
  stage: deploy
  image: alpine/helm:${HELM_VERSION}
  before_script:
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_PRODUCTION" | base64 -d > ~/.kube/config
  script:
    # Показать историю
    - helm history myapp -n production

    # Откат на предыдущую версию
    - helm rollback myapp -n production

    # Проверка
    - kubectl rollout status deployment/myapp -n production
  environment:
    name: production
    action: rollback
  only:
    - main
  when: manual

# ========================================
# Cleanup
# ========================================

cleanup:staging:
  stage: deploy
  image: alpine/helm:${HELM_VERSION}
  before_script:
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_STAGING" | base64 -d > ~/.kube/config
  script:
    - helm uninstall myapp -n staging
    - kubectl delete namespace staging
  environment:
    name: staging
    action: stop
  only:
    - develop
  when: manual

# ========================================
# Health Check после деплоя
# ========================================

verify:health-check:
  stage: deploy
  image: curlimages/curl:latest
  script:
    - sleep 30  # Ждем старта приложения
    - |
      for i in {1..10}; do
        if curl -f -s "https://staging.example.com/health"; then
          echo "✅ Health check passed"
          exit 0
        fi
        echo "⏳ Waiting... ($i/10)"
        sleep 10
      done
      echo "❌ Health check failed"
      exit 1
  needs:
    - deploy:staging:kubeconfig-var
  only:
    - develop
